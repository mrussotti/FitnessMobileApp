package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

terminal PLUS, MINUS, LPAREN, RPAREN;
terminal Long    INTCONST;

terminal RETURN, SEMICOLON, UNARYMINUS, MULTIPLY, OR, AND, NOT, LESSEQUAL, MOREEQUAL, EQUALITY, NOTEQUAL, LESS, MORE;
terminal IDENT, EQUAL, LCURLY, RCURLY, COMMA;
terminal INT, IF, ELSE, PRINT;
terminal MUTABLE, REF, Q, WHILE, FREE, NIL, DOT;

non terminal Program         program;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Stmt            stmt;
non terminal FuncDefList     funcDefList;
non terminal FuncDef         funcDef;
non terminal VarDecl         varDecl;
non terminal FormalDeclList  formalDeclList;
non terminal FormalDeclList  neFormalDeclList;
non terminal Type            type;
non terminal StmtList        stmtList;
non terminal ExprList        exprList;
non terminal ExprList        neExprList;
non terminal Cond            cond;


precedence left ELSE; // resolves dangling else
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LESSEQUAL,MOREEQUAL,EQUALITY,NOTEQUAL,LESS,MORE;
precedence left DOT;
precedence left PLUS, MINUS;
precedence left MULTIPLY;
precedence left UNARYMINUS;

start with program;

program ::= funcDefList:fl
            {: RESULT = new Program(fl, loc(flleft, flright)); :}
         ;

funcDefList ::= funcDef:e1 funcDefList:e2
            {: RESULT = new FuncDefList(e1, e2, loc(e1left, e1right)); :}
         |
            {: RESULT = null; :}
            ;

funcDef ::= varDecl:v LPAREN formalDeclList:l1 RPAREN LCURLY stmtList:l2 RCURLY
            {: RESULT = new FuncDef(v, l1, l2, loc(vleft, vright)); :}
            ;

varDecl ::= type:t IDENT:i
            {: RESULT = new VarDecl(false, t, i, loc(tleft, tright)); :}
         | MUTABLE type:t IDENT:i
            {: RESULT = new VarDecl(true, t, i, loc(tleft, tright)); :}
            ;

type ::= INT:t
            {: RESULT = new Type(Type.INT, loc(tleft, tright)); :}
         | REF:t
            {: RESULT = new Type(Type.REF, loc(tleft, tright)); :}
         | Q:t
            {: RESULT = new Type(Type.Q, loc(tleft, tright)); :}
            ;

formalDeclList ::= neFormalDeclList:l
            {: RESULT = l; :}
         | 
            {: RESULT = null; :}
            ;

neFormalDeclList ::= varDecl:v COMMA neFormalDeclList:l
            {: RESULT = new FormalDeclList(v, l, loc(vleft, vright)); :}
         |  varDecl:v
            {: RESULT = new FormalDeclList(v, null, loc(vleft, vright)); :}
            ;

stmtList ::= stmt:s stmtList:sl
            {: RESULT = new StmtList(s, sl, loc(sleft, sright)); :}
         | 
            {: RESULT = null; :}
            ;

stmt ::= varDecl:v EQUAL expr:e SEMICOLON
            {: RESULT = new Stmt(Stmt.DECL, v, e, loc(vleft, vright)); :}
         | IDENT:i EQUAL expr:e SEMICOLON
            {: RESULT = new Stmt(Stmt.ASSIGN, i, e, loc(ileft, iright)); :}
         | IF LPAREN cond:c RPAREN stmt:s
            {: RESULT = new Stmt(Stmt.IF, c, s, loc(cleft, cright)); :}
         | IF LPAREN cond:c RPAREN stmt:s ELSE stmt:s1 
            {: RESULT = new Stmt(Stmt.IFELSE, c, s, s1, loc(cleft, cright)); :}
         | WHILE LPAREN cond:c RPAREN stmt:s
            {: RESULT = new Stmt(Stmt.WHILE, c, s, loc(cleft, cright)); :}
         | IDENT:i LPAREN exprList:el RPAREN SEMICOLON
            {: RESULT = new Stmt(Stmt.CALL, i, el, loc(ileft, iright)); :}
         | FREE expr:e SEMICOLON
            {: RESULT = new Stmt(Stmt.FREE, e, loc(eleft, eright)); :}
         | PRINT expr:e SEMICOLON
            {: RESULT = new Stmt(Stmt.PRINT, e, loc(eleft, eright)); :}
         | RETURN expr:e SEMICOLON
            {: RESULT = new Stmt(Stmt.RETURN, e, loc(eleft, eright)); :}
         | LCURLY stmtList:sl RCURLY
            {: RESULT = new Stmt(Stmt.STMTGRP, sl, loc(slleft, slright)); :}
            ;

exprList ::= neExprList:el
            {: RESULT = el; :}
            | 
            {: RESULT = null; :}
            ;

neExprList ::= expr:e COMMA neExprList:el
            {: RESULT = new ExprList(e, el, loc(eleft, eright)); :}
            |  expr:e
               {: RESULT = new ExprList(e, null, loc(eleft, eright)); :}
            ;  

expr ::=  NIL
         {: RESULT = null; :}
      | INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |   IDENT:i
         {: RESULT = new IdentExpr(i, loc(ileft, iright)); :}
      |  MINUS expr:e
         {: RESULT = new BinaryExpr(new ConstExpr(0, null), BinaryExpr.MINUS, e, loc(eleft, eright)); :}
         %prec UNARYMINUS
      | LPAREN type:t RPAREN expr:e
         {: RESULT = new TypeCastExpr(t,e, loc(tleft, tright)); :}
      |   IDENT:i LPAREN exprList:el RPAREN 
         {: RESULT = new CallExpr(i, el, loc(ileft, iright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      ;

binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MULTIPLY expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MULTIPLY, e2, loc(e1left, e1right)); :}
            |  expr:e1 DOT expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.DOT, e2, loc(e1left, e1right)); :}
            ;

cond ::= expr:e1 MORE EQUAL expr:e2
            {: RESULT = new Cond(Cond.MOREEQUAL, e1, e2, loc(e1left, e1right)); :}
            %prec MOREEQUAL
         |  expr:e1 LESS EQUAL expr:e2
            {: RESULT = new Cond(Cond.LESSEQUAL, e1, e2, loc(e1left, e1right)); :}
            %prec LESSEQUAL
         |  expr:e1 EQUAL EQUAL expr:e2
            {: RESULT = new Cond(Cond.EQUALITY, e1, e2, loc(e1left, e1right)); :}
            %prec EQUALITY
         |  expr:e1 NOT EQUAL expr:e2
            {: RESULT = new Cond(Cond.NOTEQUAL, e1, e2, loc(e1left, e1right)); :}
            %prec NOTEQUAL
         |  expr:e1 LESS expr:e2
            {: RESULT = new Cond(Cond.LESS, e1, e2, loc(e1left, e1right)); :}
            %prec LESS
         |  expr:e1 MORE expr:e2
            {: RESULT = new Cond(Cond.MORE, e1, e2, loc(e1left, e1right)); :}
            %prec MORE
         |  cond:c1 AND cond:c2
            {: RESULT = new Cond(Cond.AND, c1, c2, loc(c1left, c1right)); :}
            %prec AND
         |  cond:c1 OR cond:c2
            {: RESULT = new Cond(Cond.OR, c1, c2, loc(c1left, c1right)); :}
            %prec OR
         |  NOT cond:c
            {: RESULT = new Cond(Cond.NOT, c, loc(cleft, cright)); :}
         |  LPAREN cond:c RPAREN
            {: RESULT = c; :}
            ;  














