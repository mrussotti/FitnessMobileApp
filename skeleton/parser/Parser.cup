package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

//terminal symbols
terminal PLUS, MINUS, LPAREN, RPAREN;
terminal TIMES, U_MINUS, RETURN, SEMICOLON;
terminal Long    INTCONST;

//non-terminal symbols
non terminal Program         program;
non terminal Expr            expr;
non terminal Stmt            stmt;
non terminal BinaryExpr      binaryExpr;

//operator precedence
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left U_MINUS;

//start symbol
start with program;

//beginning of grammar rules
//program may become an expression or a statement
program ::= expr:e
            {: RESULT = new Program(e, loc(eleft, eright)); :}
         |  stmt:s
            {: RESULT = new Program(s, loc(sleft, sright)); :}
         ;

//an expression will become a terminal and contains integers, parenthasis, and the unary minus
expr ::= INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
         /* format given in CUP documentation */
      | MINUS expr:e
         {: RESULT = new BinaryExpr(new ConstExpr(0, null), BinaryExpr.MINUS, e, loc(eleft, eright)); :}
         %prec U_MINUS
      ;

//a statement will become an return and handle a semicolon only for now (if/else/while/print will be added later as shown in documentation)
stmt ::= RETURN expr:e SEMICOLON
         {: RESULT = new Stmt(e, loc(eleft, eright)); :}
      ;

//a binary expression will handle the current operators
binaryExpr ::= expr:e1 PLUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 MINUS expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
            |  expr:e1 TIMES expr:e2
               {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
            ;
