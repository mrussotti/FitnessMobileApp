package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory;

import ast.*;
import interpreter.Interpreter;

parser code {: 
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }

:};

//terminal symbols
terminal DOT, PLUS, MINUS, LPAREN, RPAREN, LCURL, RCURL, PRINT, COMMA;
terminal TIMES, U_MINUS, RETURN, SEMICOLON, EQUALS;
terminal Long INTCONST;
terminal String IDENT;
terminal INT, REF, _Q;
terminal LTE, GTE, EQ, NOTEQ, LT, GT, AND, OR, NOT;
terminal IF, ELSE, WHILE, MUTABLE;

//non-terminal symbols
non terminal Program         program;
non terminal FuncDefList     funcDefList;
non terminal FuncDef         funcDef;
non terminal VarDecl         varDecl;
non terminal Type            type;
non terminal FormalDeclList  formalDeclList;
non terminal NeFormalDeclList neFormalDeclList;
non terminal StmtList        stmtList;
non terminal Stmt            stmt;
non terminal ExprList        exprList;
non terminal NeExprList      neExprList;
non terminal Expr            expr;
non terminal BinaryExpr      binaryExpr;
non terminal Cond            cond;

//operator precedence
precedence left ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left LTE, GTE, EQ, NOTEQ, LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left U_MINUS;


//start symbol
start with program;

//beginning of grammar rules
//program may become an expression or a statement
program ::= funcDefList:f
            {: RESULT = new Program(f, loc(fleft, fright)); :}
         ;

funcDefList ::= funcDef:f funcDefList:l
            {: RESULT = new FuncDefList(f, l, loc(fleft, fright)); :}
         |
            {: RESULT = null; :}
         ;

//how is location decided for the expressions with multiple non-terminals?
funcDef ::= varDecl:v LPAREN formalDeclList:f RPAREN LCURL stmtList:s RCURL
         {: RESULT = new FuncDef(v, f, s, loc(vleft, vright)); :} 
      ;

//must figure out identifier
varDecl ::= type:t IDENT:i
         {: RESULT = new VarDecl(t, i, loc(tleft, tright)); :}
      | MUTABLE type:t IDENT:i
         {: RESULT = new VarDecl(t, i, true, loc(tleft, tright)); :}
      ;

type ::=  INT:i
         {: RESULT = new Type(Type.INT, loc(ileft, iright)); :}
      | REF:r
         {: RESULT = new Type(Type.REF, loc(rleft, rright)); :}
      | _Q:q
         {: RESULT = new Type(Type.Q, loc(qleft, qright)); :}
      ;

formalDeclList ::= neFormalDeclList:n
         {: RESULT = new FormalDeclList(n, loc(nleft, nright)); :}
      |
         {: RESULT = null; :}
      ;

neFormalDeclList ::= varDecl:v COMMA neFormalDeclList:n
         {: RESULT = new NeFormalDeclList(v, n, loc(vleft, vright)); :}
      | varDecl:v
         {: RESULT = new NeFormalDeclList(v, loc(vleft, vright)); :}
      ;

stmtList ::= stmt:s stmtList:l
         {: RESULT = new StmtList(s, l, loc(sleft, sright)); :}
      |
         {: RESULT = null; :}
      ;

stmt ::= RETURN expr:e SEMICOLON
         {: RESULT = new Stmt(Stmt.RETURN, e, loc(eleft, eright)); :}
      | varDecl:v EQUALS expr:e SEMICOLON
         {: RESULT = new Stmt(Stmt.EQUALS, v, e, loc(vleft, vright)); :}
      | IDENT:i EQUALS expr:e SEMICOLON
         {: RESULT = new Stmt(Stmt.ASSIGN, i, e, loc(eleft, eright)); :}
      | IF LPAREN cond:c RPAREN stmt:s
         {: RESULT = new Stmt(Stmt.IF, c, s, loc(cleft, cright)); :}
      |  IF LPAREN cond:c RPAREN stmt:s1 ELSE stmt:s2
         {: RESULT = new Stmt(Stmt.ELSE, c, s1, s2, loc(cleft, cright)); :}
      | WHILE LPAREN cond:c RPAREN stmt:s
         {: RESULT = new Stmt(Stmt.WHILE, c, s, loc(cleft, cright)); :}
      | IDENT:i LPAREN exprList:e RPAREN SEMICOLON
         {: RESULT = new Stmt(Stmt.CALL, i, e, loc(eleft, eright)); :}
      | PRINT expr:e SEMICOLON
         {: RESULT = new Stmt(Stmt.PRINT, e, loc(eleft, eright)); :}
      | LCURL stmtList:s RCURL
         {: RESULT = new Stmt(Stmt.STMTBLOCK, s, loc(sleft, sright)); :}
      ;

exprList ::= neExprList:n
         {: RESULT = new ExprList(n, loc(nleft, nright)); :}
      |
         {: RESULT = null; :}
      ;

neExprList ::= expr:e COMMA neExprList:n
         {: RESULT = new NeExprList(e, n, loc(eleft, eright)); :}
      | expr:e
         {: RESULT = new NeExprList(e, loc(eleft, eright)); :}
      ;

//an expression will become a terminal and contains integers, parenthasis, and the unary minus
expr ::= NIL:n
         {: RESULT = nil; :}
      | INTCONST:c
         {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
      | IDENT:i
         {: RESULT = new IDENT(i, loc(ileft, iright)); :}
      | MINUS expr:e
         {: RESULT = new BinaryExpr(new ConstExpr(0, null), BinaryExpr.MINUS, e, loc(eleft, eright)); :}
         %prec U_MINUS
      | LPAREN type:t RPAREN expr:e
         {: RESULT = new TypeCast(t, e, loc(eleft, eright)); :}
      | IDENT:i LPAREN exprList:e RPAREN
         {: RESULT = new CallExpr(i, e, loc(ileft, iright)); :}
      |  binaryExpr:e
         {: RESULT = e; :}
      |  LPAREN expr:e RPAREN
         {: RESULT = e; :}
      ;


//a binary expression will handle the current operators
binaryExpr ::= expr:e1 PLUS expr:e2
         {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e1right)); :}
      |  expr:e1 MINUS expr:e2
         {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e1right)); :}
      |  expr:e1 TIMES expr:e2
         {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e1right)); :}
      | expr:e1 DOT expr:e2
         {: RESULT = new BindaryExpr(e1, BinaryExpr.DOT, e2, loc(e1left, e1right)); :}
      ;

cond ::= expr:e1 LTE expr:e2
         {: RESULT = new Cond(e1, Cond.LTE, e2, loc(e1left, e1right)); :}
      |  expr:e1 GTE expr:e2
         {: RESULT = new Cond(e1, Cond.GTE, e2, loc(e1left, e1right)); :}
      |  expr:e1 EQ expr:e2
         {: RESULT = new Cond(e1, Cond.EQ, e2, loc(e1left, e1right)); :}
      |  expr:e1 NOTEQ expr:e2
         {: RESULT = new Cond(e1, Cond.NOTEQ, e2, loc(e1left, e1right)); :}
      |  expr:e1 LT expr:e2
         {: RESULT = new Cond(e1, Cond.LT, e2, loc(e1left, e1right)); :}
      |  expr:e1 GT expr:e2
         {: RESULT = new Cond(e1, Cond.GT, e2, loc(e1left, e1right)); :}
         //Below begin with multiple conditions
      |  cond:c1 AND cond:c2
         {: RESULT = new Cond(c1, Cond.AND, c2, loc(c1left, c1right)); :}
      |  cond:c1 OR cond:c2
         {: RESULT = new Cond(c1, Cond.OR, c2, loc(c1left, c1right)); :}
         // not condition
      |  NOT cond:c
         {: RESULT = new Cond(Cond.NOT, c, loc(cleft, cright)); :}
      |  LPAREN cond:c RPAREN
         {: RESULT = c; :}
      ;
